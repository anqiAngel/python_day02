import socket


# 不定长的参数 * **

# 定义一个函数,可以求任意个数字的和
# 在定义函数时,可以在形参前面加一个*,这样这个形参将会获取到所有的实参

# a , b, *c = (1, 2, 3, 4)
# *a会接受所有的位置实参,并且会将这些实参统一保存到一个元组中 (装包)
# 之后可以对元组进行解包

# def fn(*a):
#     print('a =', a, type(a))
#
# fn(1, 2, 3, 4, 5)
# def sum(*a):
#     # 定义一个变量,来保存结果
#     result = 0
#     # 遍历元组，并将元组中的数进行累加
#     for num in a:
#         result += num
#     print(result)
# sum(10, 20, 30, 40)


# 带星号的形参只能有一个
# 带星号的参数，可以和其他参数配合使用
# 可变参数不是必须写在最后,但是注意,带*的形参之后的所有形参,必须以关键字参数的形式进行实参传递
# def(a, *b, c)
# 所有的位置参数都给a  b和c必须使用关键字参数
# def(*a, b, c)
# 如果在参数的开头直接写一个*,则要求所有的形式参数必须以关键字参数的形式传递
# def(*, a, b, c)
# *形参只能接收位置参数(元组) **可以接收关键字参数(字典)
# **形参也只能有一个,并且必须写在所有参数的最后

# 参数的解构(解包) 实参传递使用 *a 来依次给实参赋值

def fn1(a, b, c):
    print('a =', a)
    print('b =', b)
    print('c =', c)


def fn2(a, **b):
    print(a)
    print(b)


fn2(1, c=100, d=1000)
t = (1, 2, 3)
# *t对t元组进行解包
# 传递参数时,也可以在序列类型的参数前添加星号,这样他会自动将序列中的元素依次作为参数传递
# 这里要求序列中元素的个数必须和形参的个数一致
fn1(*t)
# 创建一个字典
d = {'a': 100, 'b': 200, 'c': 300}
# **对字典解包
fn1(**d)
